(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     '(5 6))
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     '(repeat 2 '(5 6)))
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     '(repeat 2 (list 5 6)))
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     '(repeat (list 5 6) 2))
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     (repeat (list 5 6) 2))
(repeat 2 "4")
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     (flatten (repeat 2 (list 5 6))))
(map (fn [x y]
         (println x y))
     '(1 2 3 4)
     (flatten (repeat 3 (list 5 6))))
(/ 1 3)
(math/round (/ 1 3))
(Math/round (/ 1 3))
(Math/round (/ 1 3) 1)
(Math/round 1 (/ 1 3))
(Math/round (/ 1 3) 2)
(Math/round (/ 1 3))
(require '[clojure.repl :refer :all])
(doc Math/round)
(apropos "round")
(find-doc "round")
(with-precision 1 (/ 1 3))
(with-precision 0 (/ 1 3))
(with-precision 0 (0.333))
(with-precision 0 0.333)
(with-precision 1 0.333)
(with-precision 3 0.333)
(with-precision 3 (/ 1M 3))
(with-precision 1 (/ 1M 3))
(with-precision 0 (/ 1M 3))
(clojure.math/round (/ 1 3))
(require '[clojure.math :as math])
(clojure.math/round (/ 1 3))
(math/round (/ 1 3))
(math/round (/ 5 3))
(math/ceil (/ 5 3))
(math.round (math/ceil (/ 5 3)))
(math/round (math/ceil (/ 5 3)))
(defn ^:private prepare-mask
  [vs mask]
  (let [c (->>
           (/ (count vs) (count mask))
           math/ceil
           math/round)]
    (repeat c mask)))
(prepare-mask '(1 2 3)
              '([[1 2] [1 1]]))
(require '[mapp.lib.gen-html :as h] :reload)
exit
